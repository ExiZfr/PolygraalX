"""
PolyGraalX Volatility Detection Module

Implements Z-Score and percentage-based volatility detection
for mean reversion trading signals.
"""

import logging
from dataclasses import dataclass
from datetime import datetime, timezone
from typing import Optional, List

import numpy as np

logger = logging.getLogger(__name__)


@dataclass
class Signal:
    """Trading signal generated by volatility detector."""
    
    asset: str                    # "BTC" or "ETH"
    direction: str                # "YES" or "NO" (betting direction)
    price_direction: str          # "UP" or "DOWN" (price movement detected)
    zscore: float                 # Z-Score value that triggered signal
    pct_move: float               # Percentage move value
    current_price: float          # Current price when signal generated
    mean_price: float             # Mean price from window
    confidence: float             # Signal confidence (0-1)
    timestamp: datetime           # When signal was generated
    
    def __repr__(self) -> str:
        return (
            f"Signal({self.asset} -> Bet {self.direction}, "
            f"Z={self.zscore:.2f}, Move={self.pct_move:.2%})"
        )


class VolatilityDetector:
    """
    Detects significant price movements for mean reversion trading.
    
    Strategy:
    - Price spikes UP (Z-Score > threshold) -> Bet NO (price will revert down)
    - Price drops DOWN (Z-Score < -threshold) -> Bet YES (price will revert up)
    """
    
    def __init__(
        self,
        zscore_threshold: float = 2.5,
        pct_threshold: float = 0.5,
        min_samples: int = 30,
        exit_zscore: float = 0.5
    ):
        """
        Args:
            zscore_threshold: Z-Score magnitude to trigger entry signal
            pct_threshold: Percentage move (0-1) to trigger entry signal
            min_samples: Minimum samples required for calculations
            exit_zscore: Z-Score magnitude to trigger exit signal
        """
        self.zscore_threshold = zscore_threshold
        self.pct_threshold = pct_threshold
        self.min_samples = min_samples
        self.exit_zscore = exit_zscore
    
    def calculate_zscore(
        self,
        prices: List[float],
        current_price: float
    ) -> float:
        """
        Calculate Z-Score for current price relative to historical distribution.
        
        Z = (current - mean) / std_dev
        
        Args:
            prices: Historical price observations
            current_price: Current/latest price
            
        Returns:
            Z-Score value (0 if insufficient data or zero variance)
        """
        if len(prices) < self.min_samples:
            return 0.0
        
        arr = np.array(prices)
        mean = arr.mean()
        std = arr.std()
        
        if std == 0 or np.isnan(std):
            return 0.0
        
        zscore = (current_price - mean) / std
        return float(zscore)
    
    def calculate_pct_move(
        self,
        prices: List[float],
        current_price: float
    ) -> float:
        """
        Calculate percentage move from window start to current price.
        
        Args:
            prices: Historical price observations
            current_price: Current/latest price
            
        Returns:
            Percentage move as decimal (e.g., 0.01 = 1%)
        """
        if not prices:
            return 0.0
        
        first_price = prices[0]
        if first_price == 0:
            return 0.0
        
        pct_move = (current_price - first_price) / first_price
        return float(pct_move)
    
    def calculate_volatility_metrics(
        self,
        prices: List[float],
        current_price: float
    ) -> tuple[float, float, float, float]:
        """
        Calculate all volatility metrics.
        
        Args:
            prices: Historical price observations
            current_price: Current/latest price
            
        Returns:
            Tuple of (zscore, pct_move, mean_price, std_dev)
        """
        if len(prices) < self.min_samples:
            return 0.0, 0.0, 0.0, 0.0
        
        arr = np.array(prices)
        mean = float(arr.mean())
        std = float(arr.std())
        
        zscore = (current_price - mean) / std if std > 0 else 0.0
        pct_move = (current_price - prices[0]) / prices[0] if prices[0] > 0 else 0.0
        
        return zscore, pct_move, mean, std
    
    def check_entry_signal(
        self,
        asset: str,
        prices: List[float],
        current_price: float
    ) -> Optional[Signal]:
        """
        Check if current conditions warrant an entry signal.
        
        Args:
            asset: Asset identifier ("BTC" or "ETH")
            prices: Historical price observations
            current_price: Current/latest price
            
        Returns:
            Signal object if entry conditions met, None otherwise
        """
        if len(prices) < self.min_samples:
            logger.debug(f"{asset}: Insufficient samples ({len(prices)}/{self.min_samples})")
            return None
        
        zscore, pct_move, mean_price, std_dev = self.calculate_volatility_metrics(
            prices, current_price
        )
        
        # Determine if we have a signal
        signal_triggered = False
        price_direction = ""
        bet_direction = ""
        confidence = 0.0
        
        # Strong upward spike -> bet NO (mean reversion down)
        if zscore >= self.zscore_threshold:
            signal_triggered = True
            price_direction = "UP"
            bet_direction = "NO"
            # Higher Z-Score = higher confidence
            confidence = min(1.0, abs(zscore) / (self.zscore_threshold * 2))
            
        # Strong downward spike -> bet YES (mean reversion up)
        elif zscore <= -self.zscore_threshold:
            signal_triggered = True
            price_direction = "DOWN"
            bet_direction = "YES"
            confidence = min(1.0, abs(zscore) / (self.zscore_threshold * 2))
        
        # Fallback: percentage move trigger
        elif abs(pct_move) >= self.pct_threshold:
            signal_triggered = True
            if pct_move > 0:
                price_direction = "UP"
                bet_direction = "NO"
            else:
                price_direction = "DOWN"
                bet_direction = "YES"
            confidence = min(1.0, abs(pct_move) / (self.pct_threshold * 2))
        
        if not signal_triggered:
            return None
        
        signal = Signal(
            asset=asset,
            direction=bet_direction,
            price_direction=price_direction,
            zscore=zscore,
            pct_move=pct_move,
            current_price=current_price,
            mean_price=mean_price,
            confidence=confidence,
            timestamp=datetime.now(timezone.utc)
        )
        
        logger.info(f"Entry signal generated: {signal}")
        return signal
    
    def check_exit_signal(
        self,
        asset: str,
        prices: List[float],
        current_price: float,
        entry_zscore: float
    ) -> bool:
        """
        Check if conditions warrant exiting a position (mean reversion complete).
        
        Args:
            asset: Asset identifier
            prices: Historical price observations
            current_price: Current/latest price
            entry_zscore: Z-Score when position was entered
            
        Returns:
            True if should exit, False otherwise
        """
        if len(prices) < self.min_samples:
            return False
        
        current_zscore = self.calculate_zscore(prices, current_price)
        
        # Exit when Z-Score returns to neutral zone
        if abs(current_zscore) <= self.exit_zscore:
            logger.info(
                f"{asset}: Exit signal - Z-Score normalized "
                f"(entry={entry_zscore:.2f}, current={current_zscore:.2f})"
            )
            return True
        
        # Exit if price reversed past mean (over-correction)
        # e.g., entered on positive Z-Score, now Z-Score is negative
        if (entry_zscore > 0 and current_zscore < -self.exit_zscore) or \
           (entry_zscore < 0 and current_zscore > self.exit_zscore):
            logger.info(
                f"{asset}: Exit signal - Price over-corrected "
                f"(entry={entry_zscore:.2f}, current={current_zscore:.2f})"
            )
            return True
        
        return False
    
    def get_market_state(
        self,
        asset: str,
        prices: List[float],
        current_price: float
    ) -> dict:
        """
        Get current market state for logging/monitoring.
        
        Returns:
            Dictionary with current volatility metrics
        """
        if len(prices) < self.min_samples:
            return {
                "asset": asset,
                "ready": False,
                "samples": len(prices),
                "required": self.min_samples
            }
        
        zscore, pct_move, mean_price, std_dev = self.calculate_volatility_metrics(
            prices, current_price
        )
        
        return {
            "asset": asset,
            "ready": True,
            "current_price": current_price,
            "mean_price": mean_price,
            "std_dev": std_dev,
            "zscore": zscore,
            "pct_move": pct_move * 100,  # Convert to percentage
            "samples": len(prices),
            "signal_threshold": self.zscore_threshold
        }
