"""
PolyGraalX Volatility Detection Module

Implements Z-Score and percentage-based volatility detection
for mean reversion trading signals.
"""

import logging
from dataclasses import dataclass
from datetime import datetime, timezone
from typing import Optional, List

import numpy as np

logger = logging.getLogger(__name__)


@dataclass
class Signal:
    """Trading signal generated by volatility detector."""
    
    asset: str                    # "BTC" or "ETH"
    direction: str                # "YES" or "NO" (betting direction)
    price_direction: str          # "UP" or "DOWN" (price movement detected)
    zscore: float                 # Z-Score value that triggered signal
    pct_move: float               # Percentage move value
    current_price: float          # Current price when signal generated
    mean_price: float             # Mean price from window
    confidence: float             # Signal confidence (0-1)
    timestamp: datetime           # When signal was generated
    
    def __repr__(self) -> str:
        return (
            f"Signal({self.asset} -> Bet {self.direction}, "
            f"Z={self.zscore:.2f}, Move={self.pct_move:.2%})"
        )


class VolatilityDetector:
    """
    Detects significant price movements for mean reversion trading.
    
    Strategy:
    - Price spikes UP (Z-Score > threshold) -> Bet NO (price will revert down)
    - Price drops DOWN (Z-Score < -threshold) -> Bet YES (price will revert up)
    """
    
    def __init__(
        self,
        zscore_threshold: float = 2.5,
        pct_threshold: float = 0.5,
        min_samples: int = 30,
        exit_zscore: float = 0.5
    ):
        """
        Args:
            zscore_threshold: Z-Score magnitude to trigger entry signal
            pct_threshold: Percentage move (0-1) to trigger entry signal
            min_samples: Minimum samples required for calculations
            exit_zscore: Z-Score magnitude to trigger exit signal
        """
        self.zscore_threshold = zscore_threshold
        self.pct_threshold = pct_threshold
        self.min_samples = min_samples
        self.exit_zscore = exit_zscore
    
    def calculate_zscore(
        self,
        prices: List[float],
        current_price: float
    ) -> float:
        """
        Calculate Z-Score for current price relative to historical distribution.
        
        Z = (current - mean) / std_dev
        
        Args:
            prices: Historical price observations
            current_price: Current/latest price
            
        Returns:
            Z-Score value (0 if insufficient data or zero variance)
        """
        if len(prices) < self.min_samples:
            return 0.0
        
        arr = np.array(prices)
        mean = arr.mean()
        std = arr.std()
        
        if std == 0 or np.isnan(std):
            return 0.0
        
        zscore = (current_price - mean) / std
        return float(zscore)
    
    def calculate_pct_move(
        self,
        prices: List[float],
        current_price: float
    ) -> float:
        """
        Calculate percentage move from window start to current price.
        
        Args:
            prices: Historical price observations
            current_price: Current/latest price
            
        Returns:
            Percentage move as decimal (e.g., 0.01 = 1%)
        """
        if not prices:
            return 0.0
        
        first_price = prices[0]
        if first_price == 0:
            return 0.0
        
        pct_move = (current_price - first_price) / first_price
        return float(pct_move)
    
    def calculate_volatility_metrics(
        self,
        prices: List[float],
        current_price: float
    ) -> tuple[float, float, float, float]:
        """
        Calculate all volatility metrics.
        
        Args:
            prices: Historical price observations
            current_price: Current/latest price
            
        Returns:
            Tuple of (zscore, pct_move, mean_price, std_dev)
        """
        if len(prices) < self.min_samples:
            return 0.0, 0.0, 0.0, 0.0
        
        arr = np.array(prices)
        mean = float(arr.mean())
        std = float(arr.std())
        
        zscore = (current_price - mean) / std if std > 0 else 0.0
        pct_move = (current_price - prices[0]) / prices[0] if prices[0] > 0 else 0.0
        
        return zscore, pct_move, mean, std
    
    def calculate_rsi(
        self,
        prices: List[float],
        period: int = 14
    ) -> float:
        """
        Calculate RSI (Relative Strength Index) indicator.
        
        RSI > 70 = Overbought (confirms SHORT signal)
        RSI < 30 = Oversold (confirms LONG signal)
        
        Args:
            prices: Historical price observations
            period: RSI period (default 14)
            
        Returns:
            RSI value (0-100), or 50.0 if insufficient data
        """
        if len(prices) < period + 1:
            return 50.0  # Neutral default
        
        # Calculate price deltas
        deltas = np.diff(prices[-(period + 1):])
        
        # Separate gains and losses
        gains = np.where(deltas > 0, deltas, 0)
        losses = np.where(deltas < 0, -deltas, 0)
        
        # Calculate average gain and loss
        avg_gain = gains.mean()
        avg_loss = losses.mean()
        
        if avg_loss == 0:
            return 100.0  # All gains
        
        # Calculate RS and RSI
        rs = avg_gain / avg_loss
        rsi = 100 - (100 / (1 + rs))
        
        return float(rsi)
    
    def check_entry_signal(
        self,
        asset: str,
        prices: List[float],
        current_price: float
    ) -> Optional[Signal]:
        """
        Check if current conditions warrant an entry signal.
        
        Args:
            asset: Asset identifier ("BTC" or "ETH")
            prices: Historical price observations
            current_price: Current/latest price
            
        Returns:
            Signal object if entry conditions met, None otherwise
        """
        if len(prices) < self.min_samples:
            logger.debug(f"{asset}: Insufficient samples ({len(prices)}/{self.min_samples})")
            return None
        
        zscore, pct_move, mean_price, std_dev = self.calculate_volatility_metrics(
            prices, current_price
        )
        
        # Calculate RSI for confirmation
        rsi = self.calculate_rsi(prices)
        
        # Determine if we have a signal (with RSI confirmation)
        signal_triggered = False
        price_direction = ""
        bet_direction = ""
        confidence = 0.0
        
        # ADJUSTED THRESHOLD: 2.5 -> 2.2 for more sensitivity
        zscore_entry_threshold = 2.2
        
        # Strong upward spike -> bet NO (mean reversion down)
        # REQUIRES: Z-Score >= 2.2 AND RSI > 70 (overbought confirmation)
        if zscore >= zscore_entry_threshold:
            if rsi > 70:
                signal_triggered = True
                price_direction = "UP"
                bet_direction = "NO"
                # Confidence: combination of Z-Score + RSI overbought strength
                zscore_conf = abs(zscore) / (zscore_entry_threshold * 2)
                rsi_conf = (rsi - 70) / 30  # 0-1 range for RSI above 70
                confidence = min(1.0, (zscore_conf + rsi_conf) / 2)
            else:
                logger.debug(
                    f"{asset}: Z-Score {zscore:.2f} triggers but RSI {rsi:.1f} < 70 "
                    f"(not overbought - possible breakout, skipping)"
                )
                return None
            
        # Strong downward spike -> bet YES (mean reversion up)
        # REQUIRES: Z-Score <= -2.2 AND RSI < 30 (oversold confirmation)
        elif zscore <= -zscore_entry_threshold:
            if rsi < 30:
                signal_triggered = True
                price_direction = "DOWN"
                bet_direction = "YES"
                # Confidence: combination of Z-Score + RSI oversold strength
                zscore_conf = abs(zscore) / (zscore_entry_threshold * 2)
                rsi_conf = (30 - rsi) / 30  # 0-1 range for RSI below 30
                confidence = min(1.0, (zscore_conf + rsi_conf) / 2)
            else:
                logger.debug(
                    f"{asset}: Z-Score {zscore:.2f} triggers but RSI {rsi:.1f} > 30 "
                    f"(not oversold - possible breakout, skipping)"
                )
                return None
        
        if not signal_triggered:
            return None
        
        signal = Signal(
            asset=asset,
            direction=bet_direction,
            price_direction=price_direction,
            zscore=zscore,
            pct_move=pct_move,
            current_price=current_price,
            mean_price=mean_price,
            confidence=confidence,
            timestamp=datetime.now(timezone.utc)
        )
        
        logger.info(
            f"âœ… Entry signal: {signal} | RSI: {rsi:.1f} | "
            f"Confidence: {confidence:.2%}"
        )
        return signal
    
    def check_exit_signal(
        self,
        asset: str,
        prices: List[float],
        current_price: float,
        entry_zscore: float
    ) -> bool:
        """
        Check if conditions warrant exiting a position (mean reversion complete).
        
        Args:
            asset: Asset identifier
            prices: Historical price observations
            current_price: Current/latest price
            entry_zscore: Z-Score when position was entered
            
        Returns:
            True if should exit, False otherwise
        """
        if len(prices) < self.min_samples:
            return False
        
        current_zscore = self.calculate_zscore(prices, current_price)
        
        # Exit when Z-Score returns to neutral zone
        if abs(current_zscore) <= self.exit_zscore:
            logger.info(
                f"{asset}: Exit signal - Z-Score normalized "
                f"(entry={entry_zscore:.2f}, current={current_zscore:.2f})"
            )
            return True
        
        # Exit if price reversed past mean (over-correction)
        # e.g., entered on positive Z-Score, now Z-Score is negative
        if (entry_zscore > 0 and current_zscore < -self.exit_zscore) or \
           (entry_zscore < 0 and current_zscore > self.exit_zscore):
            logger.info(
                f"{asset}: Exit signal - Price over-corrected "
                f"(entry={entry_zscore:.2f}, current={current_zscore:.2f})"
            )
            return True
        
        return False
    
    def get_market_state(
        self,
        asset: str,
        prices: List[float],
        current_price: float
    ) -> dict:
        """
        Get current market state for logging/monitoring.
        
        Returns:
            Dictionary with current volatility metrics
        """
        if len(prices) < self.min_samples:
            return {
                "asset": asset,
                "ready": False,
                "samples": len(prices),
                "required": self.min_samples
            }
        
        zscore, pct_move, mean_price, std_dev = self.calculate_volatility_metrics(
            prices, current_price
        )
        
        return {
            "asset": asset,
            "ready": True,
            "current_price": current_price,
            "mean_price": mean_price,
            "std_dev": std_dev,
            "zscore": zscore,
            "pct_move": pct_move * 100,  # Convert to percentage
            "samples": len(prices),
            "signal_threshold": self.zscore_threshold
        }
